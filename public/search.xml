<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue异步组件详解]]></title>
    <url>%2F2019%2F09%2F10%2Fvue-asyn-component%2F</url>
    <content type="text"><![CDATA[定义 在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。为了简化，Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。 异步组件的一个典型应用就是在配合webpack代码拆分时定义的Vue路由组件。 12345&#123; name: 'meetingList', path: 'list', component: () =&gt; import('@/views/meeting/list.vue') &#125; 上面代码component就被定义为函数返回一个promise，实质上就是一个异步组件。 异步组件的解析我们定义一个AsyncComponent的异步组件, 这个组件只有被访问到时才会加载 ~~html ~~ js components: { AsyncComponent: () =&gt; import(‘./components/test-async-component/index.vue’), }~ 以上组件在rednder时组件时会调用createElement创建vnode，对于组件createElement又会调用createComponent在createComponent内初始异步组件的代码如下。 ~~js export function createComponent ( Ctor: Class | Function | Object | void, data: ?VNodeData, context: Component, children: ?Array, tag?: string): VNode | Array | void { if (isUndef(Ctor)) { return } // Vue const baseCtor = context.$options._base // plain options object: turn it into a constructor // 对于异步组件传过来的是函数，所以不会执行Vue.extend if (isObject(Ctor)) { // 调用Vue.extend Ctor = baseCtor.extend(Ctor) } // async component // 异步组件 let asyncFactory // 异步组件没经过 Vue.extend所以不存在Ctor.cid if (isUndef(Ctor.cid)) { asyncFactory = Ctor Ctor = resolveAsyncComponent(asyncFactory, baseCtor) if (Ctor === undefined) { // 异步组件未加载完毕，且没有loading组件创建占位节点 // return a placeholder node for async component, which is rendered // as a comment node but preserves all the raw information for the node. // the information will be used for async server-rendering and hydration. return createAsyncPlaceholder( asyncFactory, data, context, children, tag ) } } return vnode} ~~ 因为此时传入Ctor是函数所以没有调用Vue.extend所以Ctor上不存在cid属性，所以会调用resolveAsyncComponent解析异步组件。 ~~jsexport function resolveAsyncComponent ( factory: Function, baseCtor: Class): Class | void { if (isTrue(factory.error) &amp;&amp; isDef(factory.errorComp)) { // 如果当前出错，返回错误组件 return factory.errorComp } if (isDef(factory.resolved)) { // 如果已经被缓存了直接返回 return factory.resolved } // 当前渲染Vue实例 const owner = currentRenderingInstance if (owner &amp;&amp; isDef(factory.owners) &amp;&amp; factory.owners.indexOf(owner) === -1) { // already pending factory.owners.push(owner) } if (isTrue(factory.loading) &amp;&amp; isDef(factory.loadingComp)) { // 返回loadding组件 return factory.loadingComp } if (owner &amp;&amp; !isDef(factory.owners)) { const owners = factory.owners = [owner] let sync = true let timerLoading = null let timerTimeout = null ;(owner: any).$on(&apos;hook:destroyed&apos;, () =&gt; remove(owners, owner)) // 在组件发生变化时触发强制更新 const forceRender = (renderCompleted: boolean) =&gt; { for (let i = 0, l = owners.length; i &lt; l; i++) { (owners[i]: any).$forceUpdate() } if (renderCompleted) { owners.length = 0 // 清除loading的计时器 if (timerLoading !== null) { clearTimeout(timerLoading) timerLoading = null } // 清除timeout计时器 if (timerTimeout !== null) { clearTimeout(timerTimeout) timerTimeout = null } } } // once确保传入的函数只执行一次，因为第一次执行后会缓存执行结果，所以函数只需要执行一次 const resolve = once((res: Object | Class&lt;Component&gt;) =&gt; { // cache resolved factory.resolved = ensureCtor(res, baseCtor) // invoke callbacks only if this is not a synchronous resolve // (async resolves are shimmed as synchronous during SSR) if (!sync) { // 组件发生变化触发强制更新 forceRender(true) } else { owners.length = 0 } }) // reject函数出错时调用 const reject = once(reason =&gt; { process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn( `Failed to resolve async component: ${String(factory)}` + (reason ? `\nReason: ${reason}` : &apos;&apos;) ) if (isDef(factory.errorComp)) { factory.error = true // 发生错误需要显示错误组件，强制更新 forceRender(true) } }) // 执行异步组件函数 // 对于普通的函数异步组件，在这一步就会返回结果 const res = factory(resolve, reject) // 如果返回的是Promise if (isObject(res)) { if (isPromise(res)) { // () =&gt; Promise if (isUndef(factory.resolved)) { // 在promise的成功回调内传入resolve， 和reject res.then(resolve, reject) } } else if (isPromise(res.component)) { // 高级的异步组件范湖一个对象，对象包含属性 res.component.then(resolve, reject) if (isDef(res.error)) { // 缓存错误组件 factory.errorComp = ensureCtor(res.error, baseCtor) } if (isDef(res.loading)) { // 缓存loading组件 factory.loadingComp = ensureCtor(res.loading, baseCtor) if (res.delay === 0) { // 设置延迟0秒 factory.loading = true } else { // 默认延迟200秒 timerLoading = setTimeout(() =&gt; { timerLoading = null if (isUndef(factory.resolved) &amp;&amp; isUndef(factory.error)) { factory.loading = true forceRender(false) } }, res.delay || 200) } } if (isDef(res.timeout)) { // 如果设置了超时时间，超时报错 timerTimeout = setTimeout(() =&gt; { timerTimeout = null if (isUndef(factory.resolved)) { reject( process.env.NODE_ENV !== &apos;production&apos; ? `timeout (${res.timeout}ms)` : null ) } }, res.timeout) } } } sync = false // return in case resolved synchronously // 最后判断如果当前正在loading返回loading组件 // 否则返回异步加载成功的组件 return factory.loading ? factory.loadingComp : factory.resolved }}function ensureCtor (comp: any, base) { if ( comp.__esModule || (hasSymbol &amp;&amp; comp[Symbol.toStringTag] === ‘Module’) ) { comp = comp.default } return isObject(comp) // 调用extend生成构造函数 ? base.extend(comp) : comp}~~ 以上代码总共有三种情况，分别代表着异步组件的三种写法。 工厂函数异步组件对于普通函数异步组件会直接在resolve函数中缓存异步组件。 js// 工厂函数异组件Vue.component(‘async-example’, function (resolve, reject) { setTimeout(function () { // 向 resolve 回调传递组件定义 resolve({ template: ‘I am async!‘ }) }, 1000)// 传入的resolve函数const resolve = once((res: Object | Class) =&gt; { // cache resolved factory.resolved = ensureCtor(res, baseCtor) // invoke callbacks only if this is not a synchronous resolve // (async resolves are shimmed as synchronous during SSR) if (!sync) { // 组件发生变化触发强制更新 forceRender(true) } else { owners.length = 0 }})~ Promsie组件除了工厂函数异步组件也是返回一个Promise ~~js// 异步组件返回一个PromiseVue.component( ‘async-webpack-example’, // 这个 import 函数会返回一个 Promise 对象。 () =&gt; import(‘./my-async-component’)) const res = factory(resolve, reject) // 如果返回的是Promiseif (isObject(res)) { if (isPromise(res)) { // () =&gt; Promise if (isUndef(factory.resolved)) { // 在promise的成功回调内传入resolve， 和reject res.then(resolve, reject) } }} ~~ 首先判断返回的是不是对象之后判断是否是Promise如果是Promise则传入resolve和reject解析异步组件，这里的resolve和reject就是前文定义的。 高级异步组件除此之外异步组件也可以返回一个对象包含下列选项 component 异步组件 loading 异步组件加载过程中的loading组件 error 加载失败时使用的组件 delay 展示加载时组件的延时时间。默认值是 200 (毫秒) timeout 如果提供了超时时间且组件加载也超时了，则使用加载失败时使用的组件。默认值是：Infinity ~~js// 异步组件返回一个对象const AsyncComponent = () =&gt; ({ // 需要加载的组件 (应该是一个 Promise 对象) component: import(‘./MyComponent.vue’), // 异步组件加载时使用的组件 loading: LoadingComponent, // 加载失败时使用的组件 error: ErrorComponent, // 展示加载时组件的延时时间。默认值是 200 (毫秒) delay: 200, // 如果提供了超时时间且组件加载也超时了， // 则使用加载失败时使用的组件。默认值是：Infinity timeout: 3000})// 解析高级异步组件 if (isObject(res)) { if (isPromise(res)) { // () =&gt; Promise if (isUndef(factory.resolved)) { // 在promise的成功回调内传入resolve， 和reject res.then(resolve, reject) } } else if (isPromise(res.component)) { // 这个分支处理高级异步组件 // 高级的异步组件范湖一个对象，对象包含属性 res.component.then(resolve, reject) if (isDef(res.error)) { // 缓存错误组件 factory.errorComp = ensureCtor(res.error, baseCtor) } if (isDef(res.loading)) { // 缓存loading组件 factory.loadingComp = ensureCtor(res.loading, baseCtor) if (res.delay === 0) { // 设置延迟0秒, 立即显示loading组件 factory.loading = true } else { // 默认延迟200秒 timerLoading = setTimeout(() =&gt; { timerLoading = null if (isUndef(factory.resolved) &amp;&amp; isUndef(factory.error)) { factory.loading = true forceRender(false) } }, res.delay || 200) } } if (isDef(res.timeout)) { // 如果设置了超时时间，超时报错 timerTimeout = setTimeout(() =&gt; { timerTimeout = null if (isUndef(factory.resolved)) { reject( process.env.NODE_ENV !== &apos;production&apos; ? `timeout (${res.timeout}ms)` : null ) } }, res.timeout) } } }~~ 由上面我们可以看到一个异步组件有下面几种状态 loading 当前组件正在加载。 error 组件加载失败，如果有设置超时时间超时未加载成功也会把状态置为error。 done 组件加载完成。 注意每次状态改变都会调用forceRender触发强制更新，因为状态改变显示的组件就会有变化。 ~~js // 在组件发生变化时触发强制更新 // 就是遍历调用实例的$forceUpdate const forceRender = (renderCompleted: boolean) =&gt; { for (let i = 0, l = owners.length; i &lt; l; i++) { (owners[i]: any).$forceUpdate() } if (renderCompleted) { owners.length = 0 // 清除计时器 if (timerLoading !== null) { clearTimeout(timerLoading) timerLoading = null } if (timerTimeout !== null) { clearTimeout(timerTimeout) timerTimeout = null } } }~~ 这里再次回到createComponet, 当组件还未加载完成，或者设置了delay，则此时resolveAsyncComponent返回了undefined,此时调用createAsyncPlaceholder创建一个占位的vnode. js if (isUndef(Ctor.cid)) { asyncFactory = Ctor Ctor = resolveAsyncComponent(asyncFactory, baseCtor) if (Ctor === undefined) { // 异步组件未加载完毕，且没有loading组件创建占位节点 // return a placeholder node for async component, which is rendered // as a comment node but preserves all the raw information for the node. // the information will be used for async server-rendering and hydration. return createAsyncPlaceholder( asyncFactory, data, context, children, tag ) } }~ jsexport function createAsyncPlaceholder ( factory: Function, data: ?VNodeData, context: Component, children: ?Array, tag: ?string): VNode { const node = createEmptyVNode() node.asyncFactory = factory node.asyncMeta = { data, context, children, tag } return node}~ 在createAsyncPlaceholder先创建一个空节点，之后将一系列上下文信息缓存在node.asyncMeta中。 由以上分析看到Vue解析异步组件的过程已经很清楚了, 需要注意的是异步组件每次状态改变都会触发强制更新，因为状态变了组件就变了，通过强制更新执行组件更新。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>web</tag>
        <tag>async</tag>
        <tag>component</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用Chrome调试微信web页面]]></title>
    <url>%2F2019%2F08%2F22%2Fwechat-web-debug%2F</url>
    <content type="text"><![CDATA[如何用Chrome调试微信web页面 微信调试有官方的微信开发者工具，这个工具很方便，但是有一个不方便就是调试公众号页面的时候，需要公众号给你授予开发者权限，但是有的时候，你仅仅只是想调试页面的样式和一些dom结构，这个时候直接用chrome调试微信web页面就显得特别方便了。 步骤（此处仅仅在android手机上做了测试）1. 打开android手机的开发者模式 和 usb调试 每个手机打开方式都不一样，请自行搜索解决方案 2. 打开chrome的 Remote Devices 3. 手机连接电脑 手机连接电脑的时候，会弹出一个usb授权提示弹窗，点解确定 4. 在Chrome上的 Remote Devices上查看链接的手机情况 5. 调试手机上的页面 点击要调试的页面的右边的 Inspect按钮，就可以打开进行调试了。 但是这个时候我们发现仅仅只能看到浏览器的页面，没有看到微信的web页面 6. 手机微信打开 http://debugx5.qq.com, 并勾选 打开TBS内核Inspector调试功能 勾选后会提示重启，点击确定就行 7. 微信上打开要调试的web 页面，就可以在chrome中看到了 8. 点击chrome中 inspect按钮及可以开始调试了]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>wechat</tag>
        <tag>chrome</tag>
        <tag>debug</tag>
      </tags>
  </entry>
</search>
