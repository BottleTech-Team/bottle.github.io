<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[解决JPEG图片横着显示的问题]]></title>
    <url>%2F2019%2F10%2F10%2F7ca7c8ccb2f3df66edbfdeb35891485c%2F</url>
    <content type="text"><![CDATA[作者： 张云峰 背景： 一些jpeg图片，在pc中用图片查看器打开是正的，但是放到浏览器中，就横着了。今天，我们就来解决这个问题。 为什么JEPG图片会横着显示？首先，我们看一个github上的一个关于此问题的issue：https://github.com/GoogleChromeLabs/squoosh/issues/299这个问题讨论的是chrome显示jpeg图片，旋转了90度的问题。为什么会旋转呢？因为JEPG图片的EXIF data中有一个控制旋转的属性Orientation，但是有一些应用程序显示图片的时候会忽略这个属性，就导致图片在一些应用程序中显示出来和原本的方向不一致。 这里有一张JEPG图片的EXIF数据（可以看到第一个属性就是 Orientation）： 让图片永远都正着显示因为 JPEG的 Orientation 属性被忽略了，那么当检测到图片Orientation的值表示需要旋转的时候，我们就主动将JPEEG图片旋转，并且改正或者去掉新图片的Orientation 字段。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 使用exif-js 这个库去获取jpeg图片的EXIF元数据 (https://github.com/exif-js/exif-js)// 旋转图片的工具,(旋转之后的图片的EXIF data被移除) import * as EXIF from 'exif-js' // npm install exif-js function fileToBuffer (file) &#123; // 读取图片数据 return new Promise(function (resolve, reject) &#123; var reader = new FileReader() reader.onload = function(evt) &#123; if (this.result instanceof ArrayBuffer) &#123; // resolve(new Uint8Array(reader.result)) resolve(this.result) &#125; &#125; reader.readAsArrayBuffer(file) &#125;) &#125; function rotateImage(file)&#123; return new Promise((resolve, reject) =&gt; &#123; fileToBuffer(file).then((binaryFile) =&gt; &#123; let meta = EXIF.readFromBinaryFile(binaryFile) let orientation = meta.Orientation let formData = new FormData() let rotationMap = &#123; 3: 180, 6: 90, 8: 270 &#125; // 3. 6， 8 分别表示旋转 180度，90度，270度 // 没有读到EXIF数据，或者Orientation属性值表示不需要旋转，修直接返回数据 if (meta === false || !rotationMap[orientation]) &#123; formData.append('file', file, 'face.jpeg') return resolve(&#123; base64: '', formData: formData, rotated: false &#125;) &#125; let rotationDegree = 0 let targetWidth = 200 rotationDegree = rotationMap[orientation] || 0 let image = document.createElement('img') image.onload = function () &#123; var canvas = document.createElement('canvas') let ctx = canvas.getContext('2d') let rate = Math.min(targetWidth / image.width, 1) let imageWidth = image.width * rate let imageHeight = image.height * rate canvas.width = canvas.height = Math.max(imageWidth, imageHeight) ctx.fillStyle = 'rgba(255, 255, 255, 0)' ctx.clearRect(0, 0, canvas.width, canvas.height) ctx.save() ctx.fillRect(0, 0, canvas.width, canvas.height) ctx.translate(canvas.width / 2, canvas.height / 2) ctx.rotate(rotationDegree * Math.PI / 180) ctx.drawImage(image, -canvas.width / 2, -canvas.height / 2 + (canvas.height - imageHeight) / 2, imageWidth, imageHeight) ctx.restore() canvas.toBlob((blob) =&gt; &#123; formData.append('file', blob, 'face.jpeg') let base64 = canvas.toDataURL('image/jpeg', 0.8) console.log('rotated image blob: ', blob) resolve(&#123; base64: base64, rotated: true, formData: formData &#125;) &#125;, 'image/jpeg', 0.8) &#125; image.src = URL.createObjectURL(file) &#125;) &#125;) &#125; 例子效果：]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>canvas</tag>
        <tag>jpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用Chrome调试微信web页面]]></title>
    <url>%2F2019%2F10%2F09%2Fwechat-web-debug%2F</url>
    <content type="text"><![CDATA[作者： 张云峰 如何用Chrome调试微信web页面 微信调试有官方的微信开发者工具，这个工具很方便，但是有一个不方便就是调试公众号页面的时候，需要公众号给你授予开发者权限，但是有的时候，你仅仅只是想调试页面的样式和一些dom结构，这个时候直接用chrome调试微信web页面就显得特别方便了。 步骤（此处仅仅在android手机上做了测试）1. 打开android手机的开发者模式 和 usb调试 每个手机打开方式都不一样，请自行搜索解决方案 2. 打开chrome的 Remote Devices 3. 手机连接电脑 手机连接电脑的时候，会弹出一个usb授权提示弹窗，点解确定 4. 在Chrome上的 Remote Devices上查看链接的手机情况 5. 调试手机上的页面 点击要调试的页面的右边的 Inspect按钮，就可以打开进行调试了。 但是这个时候我们发现仅仅只能看到浏览器的页面，没有看到微信的web页面 6. 手机微信打开 http://debugx5.qq.com, 并勾选 打开TBS内核Inspector调试功能 勾选后会提示重启，点击确定就行 7. 微信上打开要调试的web 页面，就可以在chrome中看到了 8. 点击chrome中 inspect按钮及可以开始调试了]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>wechat</tag>
        <tag>chrome</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用操作总结]]></title>
    <url>%2F2019%2F09%2F11%2Fgit-learning%2F</url>
    <content type="text"><![CDATA[作者： 张云峰 漂亮打印git log1git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr)%Creset' --abbrev-commit --date=relative 添加修改或者新文件到待commit队列12345678910### add 的文件是支持正则匹配的git add &lt;file(s)&gt;### add all changes to commiter queuegit add .### 查看某个commit的修改内容git show &lt;commit-id&gt;git diff &lt;commit-id&gt;^!##### e.g. git show d34ff657f5 git diff d34ff657f5^! 提交已添加的文件到本地仓库并创建一个新的版本1234git commit -m "commit message"### also can combine git add &amp; git commit in one commandgit commit -m "commit message" -a 推送到远程仓库12### origin 是仓库名（默认就是origin），branch_name 是分支名git push origin &lt;branch-name&gt; 仓库创建一个仓库12345### from existed repo git clone &lt;repo-url&gt;### create a new local repogit init [&lt;local-directory&gt;] 分支查看分支12345678### 查看本地分支git branch### 查看本地和远端的分支git branch -va### 查看本地分支和远程分支的对应关系git remote show &lt;repo-name&gt; ## git remote show origin 创建分支12345678910111213### 仅仅创建一个新分支在本地git checkout &lt;new-branch-name&gt;### 创建一个分支，并且将工作区切换到新创建的分支git checkout -b &lt;new-branch-name&gt;### 拉取远程分支到本地，并切换分支git checkout -b &lt;local-branch-name&gt; &lt;repo-name&gt;/&lt;remote-branch-name&gt;#### e.g.: git checkout -b test origin/test### 把远程分支拉取到本地，不切换分支 (--tranck 选项现在是默认的了)git branch &lt;local-branch-name&gt; &lt;repo-name&gt;/&lt;remote-branch-name&gt; [--track]#### e.g.: git branch test origin/test 将本地分支推送到远程仓库123456789## 远程分支不存在的情况### remote-name: 通常是 origin； local-branch-name: 本地分支名； remote-branch-name: 要创建的远程分支名 git push &lt;remote-name&gt; &lt;local-branch-name&gt;:&lt;remote-branch-name&gt; ## 远程分支存在的情况（但是没有关联） ### 首先关联本地分支和远程分支 git push -u &lt;remote-name&gt; &lt;branch-name&gt; #### or git branch --set-upstream-to=&lt;remote-name&gt;/&lt;remote-branch&gt; &lt;local-branch&gt; 更新分支1234567891011121314### 跟新本地分支git pull### 更新远程分支信息git remote update### 使用远程的代码强制更新本地的代码 （强制本地代码和线上的一致）v1.0git checkout .git pull### 使用远程的分支代码强制更新本地的代码（强制本地代码和线上的一致）v2.0git fetch --allgit reset --hard origin/mastergit pull Tag创建tag1git tag -a &lt;tag-name&gt; -m &lt;tag-message&gt; 删除tag12345678910### 删除本地taggit tag -d &lt;tag-name&gt;### 删除远端taggit push --delete &lt;repo-name&gt; &lt;tag-name&gt;or git push &lt;repo-name&gt; :refs/tags/&lt;tag-name&gt;### e.g.: git push --delete origin tag-r0### e.g.: git push origin :refs/tags/tag-r0 查看tag12345678### 查看所有的taggit tag### 查看单个taggit tag -l &lt;tag-name&gt;### 查看一个tag的具体信息git show &lt;tag-name&gt; 推送tag到远程12345## push single taggit push &lt;remote-name&gt; &lt;tag-name&gt;## push all tags (not recommended)git push --tags 撤销工作目录所有的更改（包括新创建的文件）12345678git reset --hard # removes staged and working directory changes## !! be very careful with these !!## you may end up deleting what you don't want to## read comments and manual.git clean -f -d # remove untrackedgit clean -f -x -d # CAUTION: as above but removes ignored files like config.git clean -fxd :/ # CAUTION: as above, but cleans untracked and ignored files through the entire repo (without :/, the operation affects only the current directory) git仓库存储账号密码，不用每次都输入账号密码（针对https协议的仓库地址）12345678910111213$ git config credential.helper store$ git push https://github.com/owner/repo.gitUsername for 'https://github.com': &lt;USERNAME&gt;Password for 'https://USERNAME@github.com': &lt;PASSWORD&gt;## 执行完上面的命令之后，以后所有的push都不再需要提交代码## 如果想让此功能有个时间限制，可以这样git config --global credential.helper 'cache --timeout 7200'## 7200秒后失效，push需要重新输入账号密码]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue异步组件详解]]></title>
    <url>%2F2019%2F09%2F10%2Fvue-asyn-component%2F</url>
    <content type="text"><![CDATA[作者：丁文超 定义 在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。为了简化，Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。 异步组件的一个典型应用就是在配合webpack代码拆分时定义的Vue路由组件。 12345&#123; name: 'meetingList', path: 'list', component: () =&gt; import('@/views/meeting/list.vue') &#125; 上面代码component就被定义为函数返回一个promise，实质上就是一个异步组件。 异步组件的解析我们定义一个AsyncComponent的异步组件, 这个组件只有被访问到时才会加载 123&lt;div&gt; &lt;AsyncComponent /&gt;&lt;/div&gt; 123components: &#123; AsyncComponent: () =&gt; import('./components/test-async-component/index.vue'),&#125; 以上组件在rednder时组件时会调用createElement创建vnode，对于组件createElement又会调用createComponent在createComponent内初始异步组件的代码如下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546export function createComponent ( Ctor: Class&lt;Component&gt; | Function | Object | void, data: ?VNodeData, context: Component, children: ?Array&lt;VNode&gt;, tag?: string): VNode | Array&lt;VNode&gt; | void &#123; if (isUndef(Ctor)) &#123; return &#125; // Vue const baseCtor = context.$options._base // plain options object: turn it into a constructor // 对于异步组件传过来的是函数，所以不会执行Vue.extend if (isObject(Ctor)) &#123; // 调用Vue.extend Ctor = baseCtor.extend(Ctor) &#125; // async component // 异步组件 let asyncFactory // 异步组件没经过 Vue.extend所以不存在Ctor.cid if (isUndef(Ctor.cid)) &#123; asyncFactory = Ctor Ctor = resolveAsyncComponent(asyncFactory, baseCtor) if (Ctor === undefined) &#123; // 异步组件未加载完毕，且没有loading组件创建占位节点 // return a placeholder node for async component, which is rendered // as a comment node but preserves all the raw information for the node. // the information will be used for async server-rendering and hydration. return createAsyncPlaceholder( asyncFactory, data, context, children, tag ) &#125; &#125; return vnode&#125; 因为此时传入Ctor是函数所以没有调用Vue.extend所以Ctor上不存在cid属性，所以会调用resolveAsyncComponent解析异步组件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152export function resolveAsyncComponent ( factory: Function, baseCtor: Class&lt;Component&gt;): Class&lt;Component&gt; | void &#123; if (isTrue(factory.error) &amp;&amp; isDef(factory.errorComp)) &#123; // 如果当前出错，返回错误组件 return factory.errorComp &#125; if (isDef(factory.resolved)) &#123; // 如果已经被缓存了直接返回 return factory.resolved &#125; // 当前渲染Vue实例 const owner = currentRenderingInstance if (owner &amp;&amp; isDef(factory.owners) &amp;&amp; factory.owners.indexOf(owner) === -1) &#123; // already pending factory.owners.push(owner) &#125; if (isTrue(factory.loading) &amp;&amp; isDef(factory.loadingComp)) &#123; // 返回loadding组件 return factory.loadingComp &#125; if (owner &amp;&amp; !isDef(factory.owners)) &#123; const owners = factory.owners = [owner] let sync = true let timerLoading = null let timerTimeout = null ;(owner: any).$on('hook:destroyed', () =&gt; remove(owners, owner)) // 在组件发生变化时触发强制更新 const forceRender = (renderCompleted: boolean) =&gt; &#123; for (let i = 0, l = owners.length; i &lt; l; i++) &#123; (owners[i]: any).$forceUpdate() &#125; if (renderCompleted) &#123; owners.length = 0 // 清除loading的计时器 if (timerLoading !== null) &#123; clearTimeout(timerLoading) timerLoading = null &#125; // 清除timeout计时器 if (timerTimeout !== null) &#123; clearTimeout(timerTimeout) timerTimeout = null &#125; &#125; &#125; // once确保传入的函数只执行一次，因为第一次执行后会缓存执行结果，所以函数只需要执行一次 const resolve = once((res: Object | Class&lt;Component&gt;) =&gt; &#123; // cache resolved factory.resolved = ensureCtor(res, baseCtor) // invoke callbacks only if this is not a synchronous resolve // (async resolves are shimmed as synchronous during SSR) if (!sync) &#123; // 组件发生变化触发强制更新 forceRender(true) &#125; else &#123; owners.length = 0 &#125; &#125;) // reject函数出错时调用 const reject = once(reason =&gt; &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Failed to resolve async component: $&#123;String(factory)&#125;` + (reason ? `\nReason: $&#123;reason&#125;` : '') ) if (isDef(factory.errorComp)) &#123; factory.error = true // 发生错误需要显示错误组件，强制更新 forceRender(true) &#125; &#125;) // 执行异步组件函数 // 对于普通的函数异步组件，在这一步就会返回结果 const res = factory(resolve, reject) // 如果返回的是Promise if (isObject(res)) &#123; if (isPromise(res)) &#123; // () =&gt; Promise if (isUndef(factory.resolved)) &#123; // 在promise的成功回调内传入resolve， 和reject res.then(resolve, reject) &#125; &#125; else if (isPromise(res.component)) &#123; // 高级的异步组件范湖一个对象，对象包含属性 res.component.then(resolve, reject) if (isDef(res.error)) &#123; // 缓存错误组件 factory.errorComp = ensureCtor(res.error, baseCtor) &#125; if (isDef(res.loading)) &#123; // 缓存loading组件 factory.loadingComp = ensureCtor(res.loading, baseCtor) if (res.delay === 0) &#123; // 设置延迟0秒 factory.loading = true &#125; else &#123; // 默认延迟200秒 timerLoading = setTimeout(() =&gt; &#123; timerLoading = null if (isUndef(factory.resolved) &amp;&amp; isUndef(factory.error)) &#123; factory.loading = true forceRender(false) &#125; &#125;, res.delay || 200) &#125; &#125; if (isDef(res.timeout)) &#123; // 如果设置了超时时间，超时报错 timerTimeout = setTimeout(() =&gt; &#123; timerTimeout = null if (isUndef(factory.resolved)) &#123; reject( process.env.NODE_ENV !== 'production' ? `timeout ($&#123;res.timeout&#125;ms)` : null ) &#125; &#125;, res.timeout) &#125; &#125; &#125; sync = false // return in case resolved synchronously // 最后判断如果当前正在loading返回loading组件 // 否则返回异步加载成功的组件 return factory.loading ? factory.loadingComp : factory.resolved &#125;&#125;function ensureCtor (comp: any, base) &#123; if ( comp.__esModule || (hasSymbol &amp;&amp; comp[Symbol.toStringTag] === 'Module') ) &#123; comp = comp.default &#125; return isObject(comp) // 调用extend生成构造函数 ? base.extend(comp) : comp&#125; 以上代码总共有三种情况，分别代表着异步组件的三种写法。 工厂函数异步组件对于普通函数异步组件会直接在resolve函数中缓存异步组件。 123456789101112131415161718192021// 工厂函数异组件Vue.component('async-example', function (resolve, reject) &#123; setTimeout(function () &#123; // 向 `resolve` 回调传递组件定义 resolve(&#123; template: '&lt;div&gt;I am async!&lt;/div&gt;' &#125;) &#125;, 1000)// 传入的resolve函数const resolve = once((res: Object | Class&lt;Component&gt;) =&gt; &#123; // cache resolved factory.resolved = ensureCtor(res, baseCtor) // invoke callbacks only if this is not a synchronous resolve // (async resolves are shimmed as synchronous during SSR) if (!sync) &#123; // 组件发生变化触发强制更新 forceRender(true) &#125; else &#123; owners.length = 0 &#125;&#125;) Promsie组件除了工厂函数异步组件也是返回一个Promise 123456789101112131415161718// 异步组件返回一个PromiseVue.component( 'async-webpack-example', // 这个 `import` 函数会返回一个 `Promise` 对象。 () =&gt; import('./my-async-component'))const res = factory(resolve, reject) // 如果返回的是Promiseif (isObject(res)) &#123; if (isPromise(res)) &#123; // () =&gt; Promise if (isUndef(factory.resolved)) &#123; // 在promise的成功回调内传入resolve， 和reject res.then(resolve, reject) &#125; &#125;&#125; 首先判断返回的是不是对象之后判断是否是Promise如果是Promise则传入resolve和reject解析异步组件，这里的resolve和reject就是前文定义的。 高级异步组件除此之外异步组件也可以返回一个对象包含下列选项 component 异步组件 loading 异步组件加载过程中的loading组件 error 加载失败时使用的组件 delay 展示加载时组件的延时时间。默认值是 200 (毫秒) timeout 如果提供了超时时间且组件加载也超时了，则使用加载失败时使用的组件。默认值是：Infinity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 异步组件返回一个对象const AsyncComponent = () =&gt; (&#123; // 需要加载的组件 (应该是一个 `Promise` 对象) component: import('./MyComponent.vue'), // 异步组件加载时使用的组件 loading: LoadingComponent, // 加载失败时使用的组件 error: ErrorComponent, // 展示加载时组件的延时时间。默认值是 200 (毫秒) delay: 200, // 如果提供了超时时间且组件加载也超时了， // 则使用加载失败时使用的组件。默认值是：`Infinity` timeout: 3000&#125;)// 解析高级异步组件 if (isObject(res)) &#123; if (isPromise(res)) &#123; // () =&gt; Promise if (isUndef(factory.resolved)) &#123; // 在promise的成功回调内传入resolve， 和reject res.then(resolve, reject) &#125; &#125; else if (isPromise(res.component)) &#123; // 这个分支处理高级异步组件 // 高级的异步组件范湖一个对象，对象包含属性 res.component.then(resolve, reject) if (isDef(res.error)) &#123; // 缓存错误组件 factory.errorComp = ensureCtor(res.error, baseCtor) &#125; if (isDef(res.loading)) &#123; // 缓存loading组件 factory.loadingComp = ensureCtor(res.loading, baseCtor) if (res.delay === 0) &#123; // 设置延迟0秒, 立即显示loading组件 factory.loading = true &#125; else &#123; // 默认延迟200秒 timerLoading = setTimeout(() =&gt; &#123; timerLoading = null if (isUndef(factory.resolved) &amp;&amp; isUndef(factory.error)) &#123; factory.loading = true forceRender(false) &#125; &#125;, res.delay || 200) &#125; &#125; if (isDef(res.timeout)) &#123; // 如果设置了超时时间，超时报错 timerTimeout = setTimeout(() =&gt; &#123; timerTimeout = null if (isUndef(factory.resolved)) &#123; reject( process.env.NODE_ENV !== 'production' ? `timeout ($&#123;res.timeout&#125;ms)` : null ) &#125; &#125;, res.timeout) &#125; &#125; &#125; 由上面我们可以看到一个异步组件有下面几种状态 loading 当前组件正在加载。 error 组件加载失败，如果有设置超时时间超时未加载成功也会把状态置为error。 done 组件加载完成。 注意每次状态改变都会调用forceRender触发强制更新，因为状态改变显示的组件就会有变化。 1234567891011121314151617181920// 在组件发生变化时触发强制更新// 就是遍历调用实例的$forceUpdateconst forceRender = (renderCompleted: boolean) =&gt; &#123; for (let i = 0, l = owners.length; i &lt; l; i++) &#123; (owners[i]: any).$forceUpdate() &#125; if (renderCompleted) &#123; owners.length = 0 // 清除计时器 if (timerLoading !== null) &#123; clearTimeout(timerLoading) timerLoading = null &#125; if (timerTimeout !== null) &#123; clearTimeout(timerTimeout) timerTimeout = null &#125; &#125;&#125; 这里再次回到createComponet, 当组件还未加载完成，或者设置了delay，则此时resolveAsyncComponent返回了undefined,此时调用createAsyncPlaceholder创建一个占位的vnode. 1234567891011121314151617if (isUndef(Ctor.cid)) &#123; asyncFactory = Ctor Ctor = resolveAsyncComponent(asyncFactory, baseCtor) if (Ctor === undefined) &#123; // 异步组件未加载完毕，且没有loading组件创建占位节点 // return a placeholder node for async component, which is rendered // as a comment node but preserves all the raw information for the node. // the information will be used for async server-rendering and hydration. return createAsyncPlaceholder( asyncFactory, data, context, children, tag ) &#125; &#125; 123456789101112export function createAsyncPlaceholder ( factory: Function, data: ?VNodeData, context: Component, children: ?Array&lt;VNode&gt;, tag: ?string): VNode &#123; const node = createEmptyVNode() node.asyncFactory = factory node.asyncMeta = &#123; data, context, children, tag &#125; return node&#125; 在createAsyncPlaceholder先创建一个空节点，之后将一系列上下文信息缓存在node.asyncMeta中。 由以上分析看到Vue解析异步组件的过程已经很清楚了, 需要注意的是异步组件每次状态改变都会触发强制更新，因为状态变了组件就变了，通过强制更新执行组件更新。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>web</tag>
        <tag>async</tag>
        <tag>component</tag>
      </tags>
  </entry>
</search>
