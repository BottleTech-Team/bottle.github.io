<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue异步组件详解]]></title>
    <url>%2F2019%2F09%2F10%2Fvue-asyn-component%2F</url>
    <content type="text"><![CDATA[定义 在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。为了简化，Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。 异步组件的一个典型应用就是在配合webpack代码拆分时定义的Vue路由组件。 12345&#123; name: 'meetingList', path: 'list', component: () =&gt; import('@/views/meeting/list.vue') &#125; 上面代码component就被定义为函数返回一个promise，实质上就是一个异步组件。 异步组件的解析我们定义一个AsyncComponent的异步组件, 这个组件只有被访问到时才会加载 123&lt;div&gt; &lt;AsyncComponent /&gt;&lt;/div&gt; 123components: &#123; AsyncComponent: () =&gt; import('./components/test-async-component/index.vue'),&#125; 以上组件在rednder时组件时会调用createElement创建vnode，对于组件createElement又会调用createComponent在createComponent内初始异步组件的代码如下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546export function createComponent ( Ctor: Class&lt;Component&gt; | Function | Object | void, data: ?VNodeData, context: Component, children: ?Array&lt;VNode&gt;, tag?: string): VNode | Array&lt;VNode&gt; | void &#123; if (isUndef(Ctor)) &#123; return &#125; // Vue const baseCtor = context.$options._base // plain options object: turn it into a constructor // 对于异步组件传过来的是函数，所以不会执行Vue.extend if (isObject(Ctor)) &#123; // 调用Vue.extend Ctor = baseCtor.extend(Ctor) &#125; // async component // 异步组件 let asyncFactory // 异步组件没经过 Vue.extend所以不存在Ctor.cid if (isUndef(Ctor.cid)) &#123; asyncFactory = Ctor Ctor = resolveAsyncComponent(asyncFactory, baseCtor) if (Ctor === undefined) &#123; // 异步组件未加载完毕，且没有loading组件创建占位节点 // return a placeholder node for async component, which is rendered // as a comment node but preserves all the raw information for the node. // the information will be used for async server-rendering and hydration. return createAsyncPlaceholder( asyncFactory, data, context, children, tag ) &#125; &#125; return vnode&#125; 因为此时传入Ctor是函数所以没有调用Vue.extend所以Ctor上不存在cid属性，所以会调用resolveAsyncComponent解析异步组件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152export function resolveAsyncComponent ( factory: Function, baseCtor: Class&lt;Component&gt;): Class&lt;Component&gt; | void &#123; if (isTrue(factory.error) &amp;&amp; isDef(factory.errorComp)) &#123; // 如果当前出错，返回错误组件 return factory.errorComp &#125; if (isDef(factory.resolved)) &#123; // 如果已经被缓存了直接返回 return factory.resolved &#125; // 当前渲染Vue实例 const owner = currentRenderingInstance if (owner &amp;&amp; isDef(factory.owners) &amp;&amp; factory.owners.indexOf(owner) === -1) &#123; // already pending factory.owners.push(owner) &#125; if (isTrue(factory.loading) &amp;&amp; isDef(factory.loadingComp)) &#123; // 返回loadding组件 return factory.loadingComp &#125; if (owner &amp;&amp; !isDef(factory.owners)) &#123; const owners = factory.owners = [owner] let sync = true let timerLoading = null let timerTimeout = null ;(owner: any).$on('hook:destroyed', () =&gt; remove(owners, owner)) // 在组件发生变化时触发强制更新 const forceRender = (renderCompleted: boolean) =&gt; &#123; for (let i = 0, l = owners.length; i &lt; l; i++) &#123; (owners[i]: any).$forceUpdate() &#125; if (renderCompleted) &#123; owners.length = 0 // 清除loading的计时器 if (timerLoading !== null) &#123; clearTimeout(timerLoading) timerLoading = null &#125; // 清除timeout计时器 if (timerTimeout !== null) &#123; clearTimeout(timerTimeout) timerTimeout = null &#125; &#125; &#125; // once确保传入的函数只执行一次，因为第一次执行后会缓存执行结果，所以函数只需要执行一次 const resolve = once((res: Object | Class&lt;Component&gt;) =&gt; &#123; // cache resolved factory.resolved = ensureCtor(res, baseCtor) // invoke callbacks only if this is not a synchronous resolve // (async resolves are shimmed as synchronous during SSR) if (!sync) &#123; // 组件发生变化触发强制更新 forceRender(true) &#125; else &#123; owners.length = 0 &#125; &#125;) // reject函数出错时调用 const reject = once(reason =&gt; &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Failed to resolve async component: $&#123;String(factory)&#125;` + (reason ? `\nReason: $&#123;reason&#125;` : '') ) if (isDef(factory.errorComp)) &#123; factory.error = true // 发生错误需要显示错误组件，强制更新 forceRender(true) &#125; &#125;) // 执行异步组件函数 // 对于普通的函数异步组件，在这一步就会返回结果 const res = factory(resolve, reject) // 如果返回的是Promise if (isObject(res)) &#123; if (isPromise(res)) &#123; // () =&gt; Promise if (isUndef(factory.resolved)) &#123; // 在promise的成功回调内传入resolve， 和reject res.then(resolve, reject) &#125; &#125; else if (isPromise(res.component)) &#123; // 高级的异步组件范湖一个对象，对象包含属性 res.component.then(resolve, reject) if (isDef(res.error)) &#123; // 缓存错误组件 factory.errorComp = ensureCtor(res.error, baseCtor) &#125; if (isDef(res.loading)) &#123; // 缓存loading组件 factory.loadingComp = ensureCtor(res.loading, baseCtor) if (res.delay === 0) &#123; // 设置延迟0秒 factory.loading = true &#125; else &#123; // 默认延迟200秒 timerLoading = setTimeout(() =&gt; &#123; timerLoading = null if (isUndef(factory.resolved) &amp;&amp; isUndef(factory.error)) &#123; factory.loading = true forceRender(false) &#125; &#125;, res.delay || 200) &#125; &#125; if (isDef(res.timeout)) &#123; // 如果设置了超时时间，超时报错 timerTimeout = setTimeout(() =&gt; &#123; timerTimeout = null if (isUndef(factory.resolved)) &#123; reject( process.env.NODE_ENV !== 'production' ? `timeout ($&#123;res.timeout&#125;ms)` : null ) &#125; &#125;, res.timeout) &#125; &#125; &#125; sync = false // return in case resolved synchronously // 最后判断如果当前正在loading返回loading组件 // 否则返回异步加载成功的组件 return factory.loading ? factory.loadingComp : factory.resolved &#125;&#125;function ensureCtor (comp: any, base) &#123; if ( comp.__esModule || (hasSymbol &amp;&amp; comp[Symbol.toStringTag] === 'Module') ) &#123; comp = comp.default &#125; return isObject(comp) // 调用extend生成构造函数 ? base.extend(comp) : comp&#125; 以上代码总共有三种情况，分别代表着异步组件的三种写法。 工厂函数异步组件对于普通函数异步组件会直接在resolve函数中缓存异步组件。 123456789101112131415161718192021// 工厂函数异组件Vue.component('async-example', function (resolve, reject) &#123; setTimeout(function () &#123; // 向 `resolve` 回调传递组件定义 resolve(&#123; template: '&lt;div&gt;I am async!&lt;/div&gt;' &#125;) &#125;, 1000)// 传入的resolve函数const resolve = once((res: Object | Class&lt;Component&gt;) =&gt; &#123; // cache resolved factory.resolved = ensureCtor(res, baseCtor) // invoke callbacks only if this is not a synchronous resolve // (async resolves are shimmed as synchronous during SSR) if (!sync) &#123; // 组件发生变化触发强制更新 forceRender(true) &#125; else &#123; owners.length = 0 &#125;&#125;) Promsie组件除了工厂函数异步组件也是返回一个Promise 123456789101112131415161718// 异步组件返回一个PromiseVue.component( 'async-webpack-example', // 这个 `import` 函数会返回一个 `Promise` 对象。 () =&gt; import('./my-async-component'))const res = factory(resolve, reject) // 如果返回的是Promiseif (isObject(res)) &#123; if (isPromise(res)) &#123; // () =&gt; Promise if (isUndef(factory.resolved)) &#123; // 在promise的成功回调内传入resolve， 和reject res.then(resolve, reject) &#125; &#125;&#125; 首先判断返回的是不是对象之后判断是否是Promise如果是Promise则传入resolve和reject解析异步组件，这里的resolve和reject就是前文定义的。 高级异步组件除此之外异步组件也可以返回一个对象包含下列选项 component 异步组件 loading 异步组件加载过程中的loading组件 error 加载失败时使用的组件 delay 展示加载时组件的延时时间。默认值是 200 (毫秒) timeout 如果提供了超时时间且组件加载也超时了，则使用加载失败时使用的组件。默认值是：Infinity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 异步组件返回一个对象const AsyncComponent = () =&gt; (&#123; // 需要加载的组件 (应该是一个 `Promise` 对象) component: import('./MyComponent.vue'), // 异步组件加载时使用的组件 loading: LoadingComponent, // 加载失败时使用的组件 error: ErrorComponent, // 展示加载时组件的延时时间。默认值是 200 (毫秒) delay: 200, // 如果提供了超时时间且组件加载也超时了， // 则使用加载失败时使用的组件。默认值是：`Infinity` timeout: 3000&#125;)// 解析高级异步组件 if (isObject(res)) &#123; if (isPromise(res)) &#123; // () =&gt; Promise if (isUndef(factory.resolved)) &#123; // 在promise的成功回调内传入resolve， 和reject res.then(resolve, reject) &#125; &#125; else if (isPromise(res.component)) &#123; // 这个分支处理高级异步组件 // 高级的异步组件范湖一个对象，对象包含属性 res.component.then(resolve, reject) if (isDef(res.error)) &#123; // 缓存错误组件 factory.errorComp = ensureCtor(res.error, baseCtor) &#125; if (isDef(res.loading)) &#123; // 缓存loading组件 factory.loadingComp = ensureCtor(res.loading, baseCtor) if (res.delay === 0) &#123; // 设置延迟0秒, 立即显示loading组件 factory.loading = true &#125; else &#123; // 默认延迟200秒 timerLoading = setTimeout(() =&gt; &#123; timerLoading = null if (isUndef(factory.resolved) &amp;&amp; isUndef(factory.error)) &#123; factory.loading = true forceRender(false) &#125; &#125;, res.delay || 200) &#125; &#125; if (isDef(res.timeout)) &#123; // 如果设置了超时时间，超时报错 timerTimeout = setTimeout(() =&gt; &#123; timerTimeout = null if (isUndef(factory.resolved)) &#123; reject( process.env.NODE_ENV !== 'production' ? `timeout ($&#123;res.timeout&#125;ms)` : null ) &#125; &#125;, res.timeout) &#125; &#125; &#125; 由上面我们可以看到一个异步组件有下面几种状态 loading 当前组件正在加载。 error 组件加载失败，如果有设置超时时间超时未加载成功也会把状态置为error。 done 组件加载完成。 注意每次状态改变都会调用forceRender触发强制更新，因为状态改变显示的组件就会有变化。 1234567891011121314151617181920// 在组件发生变化时触发强制更新// 就是遍历调用实例的$forceUpdateconst forceRender = (renderCompleted: boolean) =&gt; &#123; for (let i = 0, l = owners.length; i &lt; l; i++) &#123; (owners[i]: any).$forceUpdate() &#125; if (renderCompleted) &#123; owners.length = 0 // 清除计时器 if (timerLoading !== null) &#123; clearTimeout(timerLoading) timerLoading = null &#125; if (timerTimeout !== null) &#123; clearTimeout(timerTimeout) timerTimeout = null &#125; &#125;&#125; 这里再次回到createComponet, 当组件还未加载完成，或者设置了delay，则此时resolveAsyncComponent返回了undefined,此时调用createAsyncPlaceholder创建一个占位的vnode. 1234567891011121314151617if (isUndef(Ctor.cid)) &#123; asyncFactory = Ctor Ctor = resolveAsyncComponent(asyncFactory, baseCtor) if (Ctor === undefined) &#123; // 异步组件未加载完毕，且没有loading组件创建占位节点 // return a placeholder node for async component, which is rendered // as a comment node but preserves all the raw information for the node. // the information will be used for async server-rendering and hydration. return createAsyncPlaceholder( asyncFactory, data, context, children, tag ) &#125; &#125; 123456789101112export function createAsyncPlaceholder ( factory: Function, data: ?VNodeData, context: Component, children: ?Array&lt;VNode&gt;, tag: ?string): VNode &#123; const node = createEmptyVNode() node.asyncFactory = factory node.asyncMeta = &#123; data, context, children, tag &#125; return node&#125; 在createAsyncPlaceholder先创建一个空节点，之后将一系列上下文信息缓存在node.asyncMeta中。 由以上分析看到Vue解析异步组件的过程已经很清楚了, 需要注意的是异步组件每次状态改变都会触发强制更新，因为状态变了组件就变了，通过强制更新执行组件更新。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>web</tag>
        <tag>async</tag>
        <tag>component</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用Chrome调试微信web页面]]></title>
    <url>%2F2019%2F08%2F22%2Fwechat-web-debug%2F</url>
    <content type="text"><![CDATA[如何用Chrome调试微信web页面 微信调试有官方的微信开发者工具，这个工具很方便，但是有一个不方便就是调试公众号页面的时候，需要公众号给你授予开发者权限，但是有的时候，你仅仅只是想调试页面的样式和一些dom结构，这个时候直接用chrome调试微信web页面就显得特别方便了。 步骤（此处仅仅在android手机上做了测试）1. 打开android手机的开发者模式 和 usb调试 每个手机打开方式都不一样，请自行搜索解决方案 2. 打开chrome的 Remote Devices 3. 手机连接电脑 手机连接电脑的时候，会弹出一个usb授权提示弹窗，点解确定 4. 在Chrome上的 Remote Devices上查看链接的手机情况 5. 调试手机上的页面 点击要调试的页面的右边的 Inspect按钮，就可以打开进行调试了。 但是这个时候我们发现仅仅只能看到浏览器的页面，没有看到微信的web页面 6. 手机微信打开 http://debugx5.qq.com, 并勾选 打开TBS内核Inspector调试功能 勾选后会提示重启，点击确定就行 7. 微信上打开要调试的web 页面，就可以在chrome中看到了 8. 点击chrome中 inspect按钮及可以开始调试了]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>wechat</tag>
        <tag>chrome</tag>
        <tag>debug</tag>
      </tags>
  </entry>
</search>
