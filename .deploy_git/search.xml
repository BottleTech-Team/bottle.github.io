<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[web移动端支付]]></title>
    <url>%2F2019%2F10%2F16%2Faffcba87eb68badaf0269c3cb8dd509d%2F</url>
    <content type="text"><![CDATA[常见的移动端支付有：微信公众号内支付，第三方浏览器唤起微信app||支付宝app支付，微信小程序||支付宝小程序支付。 由于微信公众号内只能使用微信JSAPI支付，以及一些其他的支付方式只能在特定的环境下进行，所以需要判断h5项目代码运行的环境选择对应的支付方式： 1234567if (/MicroMessenger/.test(window.navigator.userAgent)) &#123; // 微信内&#125; else if (/AlipayClient/.test(window.navigator.userAgent)) &#123; // 支付宝内&#125; else &#123; // 第三方浏览器&#125; 由于微信支付需要用到用户的openid，进行支付前需要获取用户的openid。用户在微信客户端中访问第三方网页，公众号可以通过微信网页授权机制，来获取用户基本信息，进而实现业务逻辑。 1234567location.href = `https://open.weixin.qq.com/connect/oauth2/authorize?appid=$&#123;appid&#125;&amp;redirect_uri=$&#123;url&#125;&amp;response_type=code&amp;scope=snsapi_base&amp;state=drugstore#wechat_redirect`;// appid 必填参数 公众号的唯一标识// redirect_uri 必填参数 &quot;授权后重定向的回调链接地址， 请使用 urlEncode 对链接进行处理&quot;// response_type 必填参数 返回类型，请填写code// scope 必填参数 &quot;应用授权作用域，snsapi_base （不弹出授权页面，直接跳转，只能获取用户openid），snsapi_userinfo （弹出授权页面，可通过openid拿到昵称、性别、所在地。并且， 即使在未关注的情况下，只要用户授权，也能获取其信息 ）&quot;// state 可选参数 重定向后会带上state参数，开发者可以填写a-zA-Z0-9的参数值，最多128字节// #wechat_redirect 必填参数 无论直接打开还是做页面302重定向时候，必须带此参数 网页授权获取用户openid接口文档https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html注意：开发者需要先到公众平台官网中的“开发 - 接口权限 - 网页服务 - 网页帐号 - 网页授权获取用户基本信息”的配置选项中，修改授权回调域名。请注意，这里填写的是域名（是一个字符串），而不是URL，因此请勿加 http:// 等协议头； 微信内H5调起支付： 123456789101112131415161718192021222324252627function onBridgeReady()&#123; WeixinJSBridge.invoke( &apos;getBrandWCPayRequest&apos;, &#123; &quot;appId&quot;:&quot;wx2421b1c4370ec43b&quot;, //公众号名称，由商户传入 &quot;timeStamp&quot;:&quot;1395712654&quot;, //时间戳，自1970年以来的秒数 &quot;nonceStr&quot;:&quot;e61463f8efa94090b1f366cccfbbb444&quot;, //随机串 &quot;package&quot;:&quot;prepay_id=u802345jgfjsdfgsdg888&quot;, &quot;signType&quot;:&quot;MD5&quot;, //微信签名方式： &quot;paySign&quot;:&quot;70EA570631E4BB79628FBCA90534C63FF7FADD89&quot; //微信签名 &#125;, function(res)&#123; if(res.err_msg == &quot;get_brand_wcpay_request:ok&quot; )&#123; // 使用以上方式判断前端返回,微信团队郑重提示： //res.err_msg将在用户支付成功后返回ok，但并不保证它绝对可靠。 &#125; &#125;); &#125;if (typeof WeixinJSBridge == &quot;undefined&quot;)&#123; if( document.addEventListener )&#123; document.addEventListener(&apos;WeixinJSBridgeReady&apos;, onBridgeReady, false); &#125;else if (document.attachEvent)&#123; document.attachEvent(&apos;WeixinJSBridgeReady&apos;, onBridgeReady); document.attachEvent(&apos;onWeixinJSBridgeReady&apos;, onBridgeReady); &#125;&#125;else&#123; onBridgeReady();&#125; 微信内H5调起支付官网文档链接：https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_7&amp;index=6补充：需要在微信商户平台（pay.weixin.qq.com）设置支付目录，以及设置授权域名。具体参考https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_3 第三方浏览器唤起微信app支付： 12345678910111213//1、用户在商户侧完成下单，使用微信支付进行支付//2、由商户后台向微信支付发起下单请求（调用统一下单接口）注：交易类型trade_type=MWEB//3、统一下单接口返回支付相关参数给商户后台，如支付跳转url（参数名“mweb_url”），商户通过mweb_url调起微信支付中间页//4、中间页进行H5权限的校验，安全性检查（此处常见错误请见下文）//5、如支付成功，商户后台会接收到微信侧的异步通知//6、用户在微信支付收银台完成支付或取消支付,返回商户页面（默认为返回支付发起页面）//7、商户在展示页面，引导用户主动发起支付结果的查询//8,9、商户后台判断是否接到收微信侧的支付结果通知，如没有，后台调用我们的订单查询接口确认订单状态//10、展示最终的订单支付结果给用户// 一、回调页面//正常流程用户支付完成后会返回至发起支付的页面，如需返回至指定页面，则可以在MWEB_URL后拼接上redirect_url参数，来指定回调页面。location.href = mweb_url + &apos;&amp;redirect_url=&apos; + encodeURIComponent(&apos;回调页面地址&apos;); 补充：一.需对redirect_url进行urlencode处理。 二.由于设置redirect_url后,回跳指定页面的操作可能发生在：1,微信支付中间页调起微信收银台后超过5秒 2,用户点击“取消支付“或支付完成后点“完成”按钮。因此无法保证页面回跳时，支付流程已结束，所以商户设置的redirect_url地址不能自动执行查单操作，应让用户去点击按钮触发查单操作。 第三方浏览器唤起支付宝app支付： 1234567//端页面以Form表单的形式发起请求，浏览器会自动跳转至支付宝的相关页面（一般是收银台或签约页面），用户在该页面完成相关业务操作后再回跳到商户指定页面。const form = res.data.data; // 返回的表单const div = document.createElement(&apos;div&apos;);div.id = &apos;alipay&apos;;div.innerHTML = form;document.body.appendChild(div);document.querySelector(&apos;#alipay&apos;).children[0].submit(); // 执行后会唤起支付宝 支付宝h5支付官网文档链接：https://docs.open.alipay.com/203 微信小程序支付： 1234567891011121314151617181920wx.requestPayment(&#123; &apos;timeStamp&apos;: &apos;&apos;, //时间戳从1970年1月1日00:00:00至今的秒数,即当前的时间 &apos;nonceStr&apos;: &apos;&apos;, //随机字符串，长度为32个字符以下。 &apos;package&apos;: &apos;&apos;, //统一下单接口返回的 prepay_id 参数值，提交格式如：prepay_id=* &apos;signType&apos;: &apos;MD5&apos;, //签名类型，默认为MD5，支持HMAC-SHA256和MD5。注意此处需与统一下单的签名类型一致 &apos;paySign&apos;: &apos;&apos;, //签名,具体签名方案参见微信公众号支付帮助文档:https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=4_3; &apos;success&apos;:function(res)&#123; //接口调用成功的回调函数 //requestPayment:ok 调用支付成功 //requestPayment:fail cancel 用户取消支付 //requestPayment:fail (detail message)调用支付失败，其中 detail message 为后台返回的详细失败原因 &#125;, &apos;fail&apos;:function(res)&#123; //接口调用失败的回调函数 &#125;, &apos;complete&apos;:function(res)&#123; //接口调用结束的回调函数（调用成功、失败都会执行） &#125;&#125;) 微信小程序调起支付API官网文档链接：https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_7&amp;index=5补充：程序访问商户服务都是通过HTTPS,开发部署的时候需要安装HTTPS服务器 支付宝小程序支付： 123456789101112131415161718my.tradePay(&#123; // 调用统一收单交易创建接口（alipay.trade.create），获得返回字段支付宝交易号trade_no tradeNO: &apos;201711152100110410533667792&apos;, success: (res) =&gt; &#123; // res.resultCode === &apos;9000&apos; 订单处理成功。 &#125;, fail: (res) =&gt; &#123; &#125;&#125;);// resultCode 结果码 // 9000 订单处理成功。// 8000 正在处理中。// 4000 订单处理失败。// 6001 用户中途取消。// 6002 网络连接出错。// 6004 处理结果未知（有可能已经成功），请查询商户订单列表中订单状态。// 99 用户点击忘记密码导致快捷界面退出（only iOS）。 支付宝小程序调起支付API官网文档链接：https://docs.alipay.com/mini/api/openapi-pay补充：小程序支付在小程序内不能通过扫码、条码、声波付等方式支付，只能唤起收银台进行支付；目前小程序支付还不支持免密支付。]]></content>
      <categories>
        <category>payment</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决图片在浏览器中旋转问题]]></title>
    <url>%2F2019%2F10%2F16%2Ff03d76023fa3812362fb612b07434bdb%2F</url>
    <content type="text"><![CDATA[在开始之前需要了解为什么在浏览器中图片会自动旋转，在一些相机设备中因手持方向的原因导致图片会有一个旋转角度，在浏览器中旋转角度被忽略了，导致图片看过去是旋转的 图片旋转如下 如图1 正常6 旋转90°8 旋转-90°3 旋转180° 既然知道了图片需要旋转的角度，那么只需要通过canvas旋转并绘制图片，然后将图片输出就行，这里需要借助exif-js获取图片的源信息，只需要判断 Orientation 然后旋转对应的角度，废话不多说上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .preivew &#123; width: 300px; &#125; .preivew2 &#123; width: 300px; &#125; &lt;/style&gt; &lt;!-- 这里采用cdn形式引入exif --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/exif-js"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body&gt; &lt;input type="file" accept="image/*" /&gt; &lt;p&gt;转换前&lt;/p&gt; &lt;img class="preivew" /&gt; &lt;p&gt;转换后&lt;/p&gt; &lt;img class="preivew2" /&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; // 添加input事件监听 document.querySelector('input').addEventListener('change', onFileChange) function onFileChange(event) &#123; let file = event.target.files[0] // 得到file对象 document.querySelector('.preivew').src = URL.createObjectURL(file) // 转换前的img fixImageOrientation(file).then(blob =&gt; &#123; document.querySelector('.preivew2').src = URL.createObjectURL(blob) // 转换后的img // 上传获取到的blob对象 // let fromData = new fromData() // fromData.appendChild('file',blob) // $.ajax(&#123; // type: "method", // url: "url", // data: "data", // dataType: "dataType", // success: function (response) &#123; // &#125; // &#125;); /* *这里把转换后的blob对象下载在电脑上查看，实际开发中忽略 */ const url = window.URL.createObjectURL(blob) const link = document.createElement('a') link.href = url link.setAttribute('download', 'AAAAAA') document.body.appendChild(link) link.click() document.body.removeChild(link) window.URL.revokeObjectURL(url) &#125;) &#125; function fixImageOrientation(file) &#123; return new Promise((resolve, reject) =&gt; &#123; let img = new Image(); img.src = window.URL.createObjectURL(file); img.onerror = () =&gt; resolve(file); img.onload = () =&gt; &#123; // 获取图片源数据 上面已经引入EXIF全部变量 EXIF.getData(img, function () &#123; // 获取图片orientation值 let orientation = EXIF.getTag(this, "Orientation"); let canvas = document.createElement("canvas"); let ctx = canvas.getContext("2d"); if ([3, 6, 8].indexOf(orientation) &gt; -1) &#123; switch (orientation) &#123; case 3: // 旋转180° canvas.width = img.width; canvas.height = img.height; ctx.rotate((180 * Math.PI) / 180); ctx.drawImage(img, -img.width, -img.height, img.width, img.height); break; case 6: // 旋转90° canvas.width = img.height; canvas.height = img.width; ctx.rotate((90 * Math.PI) / 180); ctx.drawImage(img, 0, -img.height, img.width, img.height); break; case 8: // 旋转-90° canvas.width = img.height; canvas.height = img.width; ctx.rotate((-90 * Math.PI) / 180); ctx.drawImage(img, -img.width, 0, img.width, img.height); break; &#125; // 处理完返回 canvas.toBlob(file =&gt; resolve(file), 'image/jpeg', 0.92) &#125; else &#123; // 正常不需要旋转的图片，有些图片是没有源信息的，直接返回 // 这里也可以做一次压缩处理 // ... return resolve(file); &#125; &#125;); &#125;; &#125;); &#125;&lt;/script&gt; 看看效果]]></content>
      <categories>
        <category>canvas</category>
        <category>exif</category>
      </categories>
      <tags>
        <tag>图片旋转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决JPEG图片横着显示的问题]]></title>
    <url>%2F2019%2F10%2F11%2F7ca7c8ccb2f3df66edbfdeb35891485c%2F</url>
    <content type="text"><![CDATA[作者： 张云峰 背景： 一些jpeg图片，在pc中用图片查看器打开是正的，但是放到浏览器中，就横着了。今天，我们就来解决这个问题。 为什么JEPG图片会横着显示？首先，我们看一个github上的一个关于此问题的issue：https://github.com/GoogleChromeLabs/squoosh/issues/299这个问题讨论的是chrome显示jpeg图片，旋转了90度的问题。为什么会旋转呢？因为JEPG图片的EXIF data中有一个控制旋转的属性Orientation，但是有一些应用程序显示图片的时候会忽略这个属性，就导致图片在一些应用程序中显示出来和原本的方向不一致。 这里有一张JEPG图片的EXIF数据（可以看到第一个属性就是 Orientation）： 让图片永远都正着显示因为 JPEG的 Orientation 属性被忽略了，那么当检测到图片Orientation的值表示需要旋转的时候，我们就主动将JPEEG图片旋转，并且改正或者去掉新图片的Orientation 字段。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108// 使用exif-js 这个库去获取jpeg图片的EXIF元数据 (https://github.com/exif-js/exif-js)// 旋转图片的工具,(旋转之后的图片的EXIF data被移除) import * as EXIF from 'exif-js' // npm install exif-js // &lt;img id="show-image" /&gt;,用来显示旋转后的图像 var image = document.getElementById('show-image') // &lt;input id="image-input" type="file" name="imag" /&gt; var imageInput = document.getElementById('image-input') imageInput.onchange = function (evt) &#123; console.log("onchange: ...") let file = evt.target.files[0] rotateImage(file).then(data =&gt; &#123; image.src = data.base64 &#125;) &#125; function fileToBinary (file) &#123; // 读取图片数据 return new Promise(function (resolve, reject) &#123; var reader = new FileReader() reader.onload = function(evt) &#123; if (this.result instanceof ArrayBuffer) &#123; // resolve(new Uint8Array(reader.result)) resolve(this.result) &#125; &#125; reader.readAsArrayBuffer(file) &#125;) &#125; // 将Blob 对象以fileName文件名下载下来 function downloadBlob (blob, fileName) &#123; const url = window.URL.createObjectURL(blob) const link = document.createElement('a') link.href = url link.setAttribute('download', fileName) document.body.appendChild(link) link.click() document.body.removeChild(link) // 下载完成移除元素 window.URL.revokeObjectURL(url) // 释放掉blob对象 &#125; function rotateImage(file)&#123; return new Promise((resolve, reject) =&gt; &#123; fileToBinary(file).then((binaryFile) =&gt; &#123; let meta = EXIF.readFromBinaryFile(binaryFile) let orientation = meta.Orientation let formData = new FormData() let rotationMap = &#123; 3: 180, 6: 90, 8: 270 &#125; // 不需要旋转 if (meta === false || !rotationMap[orientation]) &#123; formData.append('file', file, 'face.jpeg') return resolve(&#123; base64: '', formData: formData, rotated: false &#125;) &#125; let rotationDegree = 0 let targetWidth = 200 rotationDegree = rotationMap[orientation] || 0 let image = document.createElement('img') image.onload = function () &#123; var canvas = document.createElement('canvas') let ctx = canvas.getContext('2d') let rate = Math.min(targetWidth / image.width, 1) let imageWidth = image.width * rate let imageHeight = image.height * rate if (rotationDegree === 90 || rotationDegree === 270) &#123; canvas.width = canvas.height = Math.max(imageWidth, imageHeight) &#125; else &#123; canvas.width = image.width canvas.height = image.height &#125; ctx.fillStyle = 'rgba(255, 255, 255, 0)' ctx.clearRect(0, 0, canvas.width, canvas.height) ctx.save() ctx.fillRect(0, 0, canvas.width, canvas.height) ctx.translate(canvas.width / 2, canvas.height / 2) ctx.rotate(rotationDegree * Math.PI / 180) if (rotationDegree === 90 || rotationDegree === 270) &#123; ctx.drawImage(image, -canvas.height / 2, -canvas.width / 2 + (canvas.width - imageHeight) / 2, imageWidth, imageHeight) &#125; else &#123; ctx.drawImage(image, -canvas.width / 2, -canvas.height / 2, imageWidth, imageHeight) &#125; ctx.restore() canvas.toBlob((blob) =&gt; &#123; formData.append('file', blob, 'face.jpeg') let base64 = canvas.toDataURL('image/jpeg', 0.8) console.log('rotated image blob: ', blob) // downloadBlob(blob, '123.jpg') // 下载图片 resolve(&#123; base64: base64, rotated: true, formData: formData &#125;) &#125;, 'image/jpeg', 0.8) &#125; image.src = URL.createObjectURL(file) &#125;) &#125;) &#125; 例子效果：]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>canvas</tag>
        <tag>jpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用Chrome调试微信web页面]]></title>
    <url>%2F2019%2F10%2F09%2Fwechat-web-debug%2F</url>
    <content type="text"><![CDATA[作者： 张云峰 如何用Chrome调试微信web页面 微信调试有官方的微信开发者工具，这个工具很方便，但是有一个不方便就是调试公众号页面的时候，需要公众号给你授予开发者权限，但是有的时候，你仅仅只是想调试页面的样式和一些dom结构，这个时候直接用chrome调试微信web页面就显得特别方便了。 步骤（此处仅仅在android手机上做了测试）1. 打开android手机的开发者模式 和 usb调试 每个手机打开方式都不一样，请自行搜索解决方案 2. 打开chrome的 Remote Devices 3. 手机连接电脑 手机连接电脑的时候，会弹出一个usb授权提示弹窗，点解确定 4. 在Chrome上的 Remote Devices上查看链接的手机情况 5. 调试手机上的页面 点击要调试的页面的右边的 Inspect按钮，就可以打开进行调试了。 但是这个时候我们发现仅仅只能看到浏览器的页面，没有看到微信的web页面 6. 手机微信打开 http://debugx5.qq.com, 并勾选 打开TBS内核Inspector调试功能 勾选后会提示重启，点击确定就行 7. 微信上打开要调试的web 页面，就可以在chrome中看到了 8. 点击chrome中 inspect按钮及可以开始调试了]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>wechat</tag>
        <tag>chrome</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用操作总结]]></title>
    <url>%2F2019%2F09%2F11%2Fgit-learning%2F</url>
    <content type="text"><![CDATA[作者： 张云峰 漂亮打印git log1git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr)%Creset' --abbrev-commit --date=relative 添加修改或者新文件到待commit队列12345678910### add 的文件是支持正则匹配的git add &lt;file(s)&gt;### add all changes to commiter queuegit add .### 查看某个commit的修改内容git show &lt;commit-id&gt;git diff &lt;commit-id&gt;^!##### e.g. git show d34ff657f5 git diff d34ff657f5^! 提交已添加的文件到本地仓库并创建一个新的版本1234git commit -m "commit message"### also can combine git add &amp; git commit in one commandgit commit -m "commit message" -a 推送到远程仓库12### origin 是仓库名（默认就是origin），branch_name 是分支名git push origin &lt;branch-name&gt; 仓库创建一个仓库12345### from existed repo git clone &lt;repo-url&gt;### create a new local repogit init [&lt;local-directory&gt;] 分支查看分支12345678### 查看本地分支git branch### 查看本地和远端的分支git branch -va### 查看本地分支和远程分支的对应关系git remote show &lt;repo-name&gt; ## git remote show origin 创建分支12345678910111213### 仅仅创建一个新分支在本地git checkout &lt;new-branch-name&gt;### 创建一个分支，并且将工作区切换到新创建的分支git checkout -b &lt;new-branch-name&gt;### 拉取远程分支到本地，并切换分支git checkout -b &lt;local-branch-name&gt; &lt;repo-name&gt;/&lt;remote-branch-name&gt;#### e.g.: git checkout -b test origin/test### 把远程分支拉取到本地，不切换分支 (--tranck 选项现在是默认的了)git branch &lt;local-branch-name&gt; &lt;repo-name&gt;/&lt;remote-branch-name&gt; [--track]#### e.g.: git branch test origin/test 将本地分支推送到远程仓库123456789## 远程分支不存在的情况### remote-name: 通常是 origin； local-branch-name: 本地分支名； remote-branch-name: 要创建的远程分支名 git push &lt;remote-name&gt; &lt;local-branch-name&gt;:&lt;remote-branch-name&gt; ## 远程分支存在的情况（但是没有关联） ### 首先关联本地分支和远程分支 git push -u &lt;remote-name&gt; &lt;branch-name&gt; #### or git branch --set-upstream-to=&lt;remote-name&gt;/&lt;remote-branch&gt; &lt;local-branch&gt; 更新分支1234567891011121314### 跟新本地分支git pull### 更新远程分支信息git remote update### 使用远程的代码强制更新本地的代码 （强制本地代码和线上的一致）v1.0git checkout .git pull### 使用远程的分支代码强制更新本地的代码（强制本地代码和线上的一致）v2.0git fetch --allgit reset --hard origin/mastergit pull Tag创建tag1git tag -a &lt;tag-name&gt; -m &lt;tag-message&gt; 删除tag12345678910### 删除本地taggit tag -d &lt;tag-name&gt;### 删除远端taggit push --delete &lt;repo-name&gt; &lt;tag-name&gt;or git push &lt;repo-name&gt; :refs/tags/&lt;tag-name&gt;### e.g.: git push --delete origin tag-r0### e.g.: git push origin :refs/tags/tag-r0 查看tag12345678### 查看所有的taggit tag### 查看单个taggit tag -l &lt;tag-name&gt;### 查看一个tag的具体信息git show &lt;tag-name&gt; 推送tag到远程12345## push single taggit push &lt;remote-name&gt; &lt;tag-name&gt;## push all tags (not recommended)git push --tags 撤销工作目录所有的更改（包括新创建的文件）12345678git reset --hard # removes staged and working directory changes## !! be very careful with these !!## you may end up deleting what you don't want to## read comments and manual.git clean -f -d # remove untrackedgit clean -f -x -d # CAUTION: as above but removes ignored files like config.git clean -fxd :/ # CAUTION: as above, but cleans untracked and ignored files through the entire repo (without :/, the operation affects only the current directory) git仓库存储账号密码，不用每次都输入账号密码（针对https协议的仓库地址）12345678910111213$ git config credential.helper store$ git push https://github.com/owner/repo.gitUsername for 'https://github.com': &lt;USERNAME&gt;Password for 'https://USERNAME@github.com': &lt;PASSWORD&gt;## 执行完上面的命令之后，以后所有的push都不再需要提交代码## 如果想让此功能有个时间限制，可以这样git config --global credential.helper 'cache --timeout 7200'## 7200秒后失效，push需要重新输入账号密码]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue异步组件详解]]></title>
    <url>%2F2019%2F09%2F10%2Fvue-asyn-component%2F</url>
    <content type="text"><![CDATA[作者：丁文超 定义 在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。为了简化，Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。 异步组件的一个典型应用就是在配合webpack代码拆分时定义的Vue路由组件。 12345&#123; name: 'meetingList', path: 'list', component: () =&gt; import('@/views/meeting/list.vue') &#125; 上面代码component就被定义为函数返回一个promise，实质上就是一个异步组件。 异步组件的解析我们定义一个AsyncComponent的异步组件, 这个组件只有被访问到时才会加载 123&lt;div&gt; &lt;AsyncComponent /&gt;&lt;/div&gt; 123components: &#123; AsyncComponent: () =&gt; import('./components/test-async-component/index.vue'),&#125; 以上组件在rednder时组件时会调用createElement创建vnode，对于组件createElement又会调用createComponent在createComponent内初始异步组件的代码如下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546export function createComponent ( Ctor: Class&lt;Component&gt; | Function | Object | void, data: ?VNodeData, context: Component, children: ?Array&lt;VNode&gt;, tag?: string): VNode | Array&lt;VNode&gt; | void &#123; if (isUndef(Ctor)) &#123; return &#125; // Vue const baseCtor = context.$options._base // plain options object: turn it into a constructor // 对于异步组件传过来的是函数，所以不会执行Vue.extend if (isObject(Ctor)) &#123; // 调用Vue.extend Ctor = baseCtor.extend(Ctor) &#125; // async component // 异步组件 let asyncFactory // 异步组件没经过 Vue.extend所以不存在Ctor.cid if (isUndef(Ctor.cid)) &#123; asyncFactory = Ctor Ctor = resolveAsyncComponent(asyncFactory, baseCtor) if (Ctor === undefined) &#123; // 异步组件未加载完毕，且没有loading组件创建占位节点 // return a placeholder node for async component, which is rendered // as a comment node but preserves all the raw information for the node. // the information will be used for async server-rendering and hydration. return createAsyncPlaceholder( asyncFactory, data, context, children, tag ) &#125; &#125; return vnode&#125; 因为此时传入Ctor是函数所以没有调用Vue.extend所以Ctor上不存在cid属性，所以会调用resolveAsyncComponent解析异步组件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152export function resolveAsyncComponent ( factory: Function, baseCtor: Class&lt;Component&gt;): Class&lt;Component&gt; | void &#123; if (isTrue(factory.error) &amp;&amp; isDef(factory.errorComp)) &#123; // 如果当前出错，返回错误组件 return factory.errorComp &#125; if (isDef(factory.resolved)) &#123; // 如果已经被缓存了直接返回 return factory.resolved &#125; // 当前渲染Vue实例 const owner = currentRenderingInstance if (owner &amp;&amp; isDef(factory.owners) &amp;&amp; factory.owners.indexOf(owner) === -1) &#123; // already pending factory.owners.push(owner) &#125; if (isTrue(factory.loading) &amp;&amp; isDef(factory.loadingComp)) &#123; // 返回loadding组件 return factory.loadingComp &#125; if (owner &amp;&amp; !isDef(factory.owners)) &#123; const owners = factory.owners = [owner] let sync = true let timerLoading = null let timerTimeout = null ;(owner: any).$on('hook:destroyed', () =&gt; remove(owners, owner)) // 在组件发生变化时触发强制更新 const forceRender = (renderCompleted: boolean) =&gt; &#123; for (let i = 0, l = owners.length; i &lt; l; i++) &#123; (owners[i]: any).$forceUpdate() &#125; if (renderCompleted) &#123; owners.length = 0 // 清除loading的计时器 if (timerLoading !== null) &#123; clearTimeout(timerLoading) timerLoading = null &#125; // 清除timeout计时器 if (timerTimeout !== null) &#123; clearTimeout(timerTimeout) timerTimeout = null &#125; &#125; &#125; // once确保传入的函数只执行一次，因为第一次执行后会缓存执行结果，所以函数只需要执行一次 const resolve = once((res: Object | Class&lt;Component&gt;) =&gt; &#123; // cache resolved factory.resolved = ensureCtor(res, baseCtor) // invoke callbacks only if this is not a synchronous resolve // (async resolves are shimmed as synchronous during SSR) if (!sync) &#123; // 组件发生变化触发强制更新 forceRender(true) &#125; else &#123; owners.length = 0 &#125; &#125;) // reject函数出错时调用 const reject = once(reason =&gt; &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Failed to resolve async component: $&#123;String(factory)&#125;` + (reason ? `\nReason: $&#123;reason&#125;` : '') ) if (isDef(factory.errorComp)) &#123; factory.error = true // 发生错误需要显示错误组件，强制更新 forceRender(true) &#125; &#125;) // 执行异步组件函数 // 对于普通的函数异步组件，在这一步就会返回结果 const res = factory(resolve, reject) // 如果返回的是Promise if (isObject(res)) &#123; if (isPromise(res)) &#123; // () =&gt; Promise if (isUndef(factory.resolved)) &#123; // 在promise的成功回调内传入resolve， 和reject res.then(resolve, reject) &#125; &#125; else if (isPromise(res.component)) &#123; // 高级的异步组件范湖一个对象，对象包含属性 res.component.then(resolve, reject) if (isDef(res.error)) &#123; // 缓存错误组件 factory.errorComp = ensureCtor(res.error, baseCtor) &#125; if (isDef(res.loading)) &#123; // 缓存loading组件 factory.loadingComp = ensureCtor(res.loading, baseCtor) if (res.delay === 0) &#123; // 设置延迟0秒 factory.loading = true &#125; else &#123; // 默认延迟200秒 timerLoading = setTimeout(() =&gt; &#123; timerLoading = null if (isUndef(factory.resolved) &amp;&amp; isUndef(factory.error)) &#123; factory.loading = true forceRender(false) &#125; &#125;, res.delay || 200) &#125; &#125; if (isDef(res.timeout)) &#123; // 如果设置了超时时间，超时报错 timerTimeout = setTimeout(() =&gt; &#123; timerTimeout = null if (isUndef(factory.resolved)) &#123; reject( process.env.NODE_ENV !== 'production' ? `timeout ($&#123;res.timeout&#125;ms)` : null ) &#125; &#125;, res.timeout) &#125; &#125; &#125; sync = false // return in case resolved synchronously // 最后判断如果当前正在loading返回loading组件 // 否则返回异步加载成功的组件 return factory.loading ? factory.loadingComp : factory.resolved &#125;&#125;function ensureCtor (comp: any, base) &#123; if ( comp.__esModule || (hasSymbol &amp;&amp; comp[Symbol.toStringTag] === 'Module') ) &#123; comp = comp.default &#125; return isObject(comp) // 调用extend生成构造函数 ? base.extend(comp) : comp&#125; 以上代码总共有三种情况，分别代表着异步组件的三种写法。 工厂函数异步组件对于普通函数异步组件会直接在resolve函数中缓存异步组件。 123456789101112131415161718192021// 工厂函数异组件Vue.component('async-example', function (resolve, reject) &#123; setTimeout(function () &#123; // 向 `resolve` 回调传递组件定义 resolve(&#123; template: '&lt;div&gt;I am async!&lt;/div&gt;' &#125;) &#125;, 1000)// 传入的resolve函数const resolve = once((res: Object | Class&lt;Component&gt;) =&gt; &#123; // cache resolved factory.resolved = ensureCtor(res, baseCtor) // invoke callbacks only if this is not a synchronous resolve // (async resolves are shimmed as synchronous during SSR) if (!sync) &#123; // 组件发生变化触发强制更新 forceRender(true) &#125; else &#123; owners.length = 0 &#125;&#125;) Promsie组件除了工厂函数异步组件也是返回一个Promise 123456789101112131415161718// 异步组件返回一个PromiseVue.component( 'async-webpack-example', // 这个 `import` 函数会返回一个 `Promise` 对象。 () =&gt; import('./my-async-component'))const res = factory(resolve, reject) // 如果返回的是Promiseif (isObject(res)) &#123; if (isPromise(res)) &#123; // () =&gt; Promise if (isUndef(factory.resolved)) &#123; // 在promise的成功回调内传入resolve， 和reject res.then(resolve, reject) &#125; &#125;&#125; 首先判断返回的是不是对象之后判断是否是Promise如果是Promise则传入resolve和reject解析异步组件，这里的resolve和reject就是前文定义的。 高级异步组件除此之外异步组件也可以返回一个对象包含下列选项 component 异步组件 loading 异步组件加载过程中的loading组件 error 加载失败时使用的组件 delay 展示加载时组件的延时时间。默认值是 200 (毫秒) timeout 如果提供了超时时间且组件加载也超时了，则使用加载失败时使用的组件。默认值是：Infinity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 异步组件返回一个对象const AsyncComponent = () =&gt; (&#123; // 需要加载的组件 (应该是一个 `Promise` 对象) component: import('./MyComponent.vue'), // 异步组件加载时使用的组件 loading: LoadingComponent, // 加载失败时使用的组件 error: ErrorComponent, // 展示加载时组件的延时时间。默认值是 200 (毫秒) delay: 200, // 如果提供了超时时间且组件加载也超时了， // 则使用加载失败时使用的组件。默认值是：`Infinity` timeout: 3000&#125;)// 解析高级异步组件 if (isObject(res)) &#123; if (isPromise(res)) &#123; // () =&gt; Promise if (isUndef(factory.resolved)) &#123; // 在promise的成功回调内传入resolve， 和reject res.then(resolve, reject) &#125; &#125; else if (isPromise(res.component)) &#123; // 这个分支处理高级异步组件 // 高级的异步组件范湖一个对象，对象包含属性 res.component.then(resolve, reject) if (isDef(res.error)) &#123; // 缓存错误组件 factory.errorComp = ensureCtor(res.error, baseCtor) &#125; if (isDef(res.loading)) &#123; // 缓存loading组件 factory.loadingComp = ensureCtor(res.loading, baseCtor) if (res.delay === 0) &#123; // 设置延迟0秒, 立即显示loading组件 factory.loading = true &#125; else &#123; // 默认延迟200秒 timerLoading = setTimeout(() =&gt; &#123; timerLoading = null if (isUndef(factory.resolved) &amp;&amp; isUndef(factory.error)) &#123; factory.loading = true forceRender(false) &#125; &#125;, res.delay || 200) &#125; &#125; if (isDef(res.timeout)) &#123; // 如果设置了超时时间，超时报错 timerTimeout = setTimeout(() =&gt; &#123; timerTimeout = null if (isUndef(factory.resolved)) &#123; reject( process.env.NODE_ENV !== 'production' ? `timeout ($&#123;res.timeout&#125;ms)` : null ) &#125; &#125;, res.timeout) &#125; &#125; &#125; 由上面我们可以看到一个异步组件有下面几种状态 loading 当前组件正在加载。 error 组件加载失败，如果有设置超时时间超时未加载成功也会把状态置为error。 done 组件加载完成。 注意每次状态改变都会调用forceRender触发强制更新，因为状态改变显示的组件就会有变化。 1234567891011121314151617181920// 在组件发生变化时触发强制更新// 就是遍历调用实例的$forceUpdateconst forceRender = (renderCompleted: boolean) =&gt; &#123; for (let i = 0, l = owners.length; i &lt; l; i++) &#123; (owners[i]: any).$forceUpdate() &#125; if (renderCompleted) &#123; owners.length = 0 // 清除计时器 if (timerLoading !== null) &#123; clearTimeout(timerLoading) timerLoading = null &#125; if (timerTimeout !== null) &#123; clearTimeout(timerTimeout) timerTimeout = null &#125; &#125;&#125; 这里再次回到createComponet, 当组件还未加载完成，或者设置了delay，则此时resolveAsyncComponent返回了undefined,此时调用createAsyncPlaceholder创建一个占位的vnode. 1234567891011121314151617if (isUndef(Ctor.cid)) &#123; asyncFactory = Ctor Ctor = resolveAsyncComponent(asyncFactory, baseCtor) if (Ctor === undefined) &#123; // 异步组件未加载完毕，且没有loading组件创建占位节点 // return a placeholder node for async component, which is rendered // as a comment node but preserves all the raw information for the node. // the information will be used for async server-rendering and hydration. return createAsyncPlaceholder( asyncFactory, data, context, children, tag ) &#125; &#125; 123456789101112export function createAsyncPlaceholder ( factory: Function, data: ?VNodeData, context: Component, children: ?Array&lt;VNode&gt;, tag: ?string): VNode &#123; const node = createEmptyVNode() node.asyncFactory = factory node.asyncMeta = &#123; data, context, children, tag &#125; return node&#125; 在createAsyncPlaceholder先创建一个空节点，之后将一系列上下文信息缓存在node.asyncMeta中。 由以上分析看到Vue解析异步组件的过程已经很清楚了, 需要注意的是异步组件每次状态改变都会触发强制更新，因为状态变了组件就变了，通过强制更新执行组件更新。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>vue</tag>
        <tag>async</tag>
        <tag>component</tag>
      </tags>
  </entry>
</search>
